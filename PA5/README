README file for Programming Assignment 5  (C++ edition)
=======================================================

Your directory should now contain the following files:

 Makefile
 README
 ast-lex.cc	      -> [cool root]/src/PA5/ast-lex.cc
 ast-parse.cc	      -> [cool root]/src/PA5/ast-parse.cc
 cgen-phase.cc	      -> [cool root]/src/PA5/cgen-phase.cc
 cgen.cc
 cgen.h
 cgen_supp.cc
 cool-tree.cc	      -> [cool root]/src/PA5/cool-tree.cc
 cool-tree.handcode.h
 dumptype.cc	      -> [cool root]/src/PA5/dumptype.cc
 emit.h
 example.cl
 handle_flags.cc      -> [cool root]/src/PA5/handle_flags.cc
 mycoolc	      -> [cool root]/src/PA5/mycoolc*
 stringtab.cc	      -> [cool root]/src/PA5/stringtab.cc
 tree.cc	      -> [cool root]/src/PA5/tree.cc
 utilities.cc	      -> [cool root]/src/PA5/utilities.cc
 *.d

The include (.h) files for this assignment can be found in 
[cool root]/include/PA5

	The Makefile contains targets for compiling and running your
	program, as well as handing it in. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to
	fill the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct,
	and why your test cases are adequate. It is part of the
	assignment to clearly and concisely explain things in text as
	well as to comment your code. Just edit this file.

	In example.cl you should write a correct Cool program which
	tests as many aspects of the code generator as possible. It
	should pass your code generator, and running spim on the
	generated output should run the program correctly.

	cgen.cc is the skeleton file for the code generator. This
	skeleton is much larger than the ones for previous
	assignments.  The skeleton provides three components of the
	code generator:

		- functions to build the inheritance graph; (we supply
		  this in case you didn't get this working for PA4)

		- functions to emit global data and constants;
		 
		- functions to emit spim instructions; (we supply
		  these last two to save you some tedious coding)

	You should work to understand this code, and it will help you
        write the rest of the code generator.

	cgen.h is the header file for the code generator. Feel free to
	add anything you need.

	cgen_supp.cc is general support code for the code generator.
	You can add functions as you see fit, but do not modify the 3
	functions:

		o byte_mode
		o ascii_mode
		o emit_string_constant

	emit.h defines a bunch of macros which should come in handy
	when you actually want to emit code. Feel free to change
	anything here to suit your needs.

        cgen-phase.cc supplies the driver for the compiler. You should
        not modify this code.  The script mycoolc can pass any of the
        standard flags to the code generator; for this assignment, -c
        (code generator debug) may be useful as it sets a global
        variable cgen_debug to true (1).  If you want your code
        generator to print debug information when the option is set,
        write your debug code in the following format:

	      if (cgen_debug)
	      {
		...
	      }

	symtab.h contains a symbol table implementation. You may
        modify this file if you'd like.  To do so, remove the link and
        copy `[course dir]/include/PA5/symtab.h' to your local
        directory.

	cool.h contains definitions that are used by almost all parts
	of the compiler. DO NOT MODIFY.

        tree.h contains the base class `tree_node' of the AST nodes.

        cool-tree.cc, cool-tree.h, and cool-tree.handcode.h contain
        the declarations and definitions of code generation AST nodes.
        You may add fields as you wish, but you shouldn't modify any
        of the methods already there except `code', which you may
        modify or remove as you wish.  Note that cool-tree.handcode.h
        is different from the same file in PA4---this file contains
        function definitions needed for the cgen.cc skeleton.  You may
        modify cool-tree.h or cool-tree.handcode.h, but don't modify
        cool-tree.cc.  Place all method definitions in cgen.cc

	stringtab.h contains functions to manipulate the string table.
	DO NOT MODIFY.

	dumptype.cc contains functions for printing out an abstract
	syntax tree.  DO NOT MODIFY.

        *.d dependency files, generated automatically by the makefile.

Instructions
------------

	To compile your compiler and code generator type:

	% gmake cgen

	To test your compiler, type:

	% ./mycoolc [-o output filename] <file1.cl> <file2.cl> ...

	This command parses all the cool files given on the command
	line, passes them through the semantic checker, and then hands
	the program AST to your code generator.

	To run your compiler on the file example.cl, type:

	% gmake dotest

	To run the produced code:

	% [cool root]/bin/spim -file file1.s
      /* or the output filename you chose */
	
	If you change architectures you must issue

	% gmake clean

	when you switch from one type of machine to the other.  If at
	some point you get weird errors from the linker, you probably
	forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA5
----------------
==================================================================================================
Trabalho apresentado à disciplina de compiladores do Curso de Ciência da Computação da PUC - Minas
Alunos: Rossana Souza, Lucas Milard, Natan Alexandre, Luam Gonçalves
==================================================================================================

O método code da classe `static_dispatch_class` representa uma chamada de método estática. A função code é responsável por gerar o código correspondente a essa chamada. O código começa com a obtenção dos argumentos atuais e do tipo de destino da chamada. Em seguida, são gerados os códigos para cada argumento atual, empilhando os valores na pilha de execução. O objeto de despacho é então colocado em ACC. Em seguida, é verificado se o objeto de despacho é vazio e, se for, é emitido um código de aborto. Caso contrário, é realizado o despacho para o objeto válido, carregando o endereço do método correspondente e realizando um salto indireto.

A estratégia adotada para a geração de código leva em consideração a obtenção dos argumentos atuais, o carregamento do objeto de despacho, a verificação de nulidade do objeto e o despacho para o método apropriado. Essa estratégia visa garantir a correta execução da chamada de método estática, lidando adequadamente com casos em que o objeto de despacho não é válido.

O método code da classe `assign_class` gera código para atribuir um valor a uma variável em um compilador ou interpretador. Ela avalia a expressão do valor a ser atribuído e, em seguida, verifica em qual escopo a variável está presente (escopo atual, argumentos de método ou atributos da classe). Com base nisso, o código gerado armazena o valor no local apropriado (pilha de escopos, frame do método ou objeto da classe) e pode executar uma coleta de lixo, se necessário. Em resumo, A classe realiza a atribuição do valor e gera o código correspondente para essa operação.

O método code da classe `cond_class` gera código para uma construção condicional (if-then-else) em um compilador ou interpretador. Ela avalia um predicado, executa o bloco de código correspondente se o predicado for verdadeiro e o bloco de código alternativo se o predicado for falso. O código gerado inclui instruções de salto condicional e incondicional para controlar o fluxo de execução. Em resumo, a classe produz o código assembly ou bytecode necessário para implementar uma estrutura condicional em uma linguagem de programação.

O método code da classe `loop_class` implementa a geração de código para um loop. O loop é controlado por um predicado, representado pela expressão pred. O corpo do loop, representado pela expressão body, é repetidamente executado enquanto o predicado for verdadeiro. O loop começa com a avaliação do predicado. Se o valor for zero, o loop é interrompido e o código continua após o loop. Caso contrário, o corpo do loop é executado. Após a execução do corpo, o código volta para avaliar novamente o predicado e continua repetindo esse processo até que o predicado falhe. Ao sair do loop, o valor zero é atribuído ao registrador ACC para garantir que seu valor seja zero após o loop. Isso garante que o resultado do loop seja zero quando o predicado falhar.

O método code da classe `block_class` gera o código para uma sequência de expressões em um bloco. A classe itera sobre as expressões contidas no bloco, usando um loop for. Para cada expressão, o código correspondente é gerado chamando o método code da expressão. O parâmetro s é o fluxo de saída onde o código é escrito, e ctx é o contexto de compilação que contém informações úteis durante a geração de código.

O método code da classe `let_class` gera o código para uma expressão "let". Ela otimiza a geração de código verificando se é necessário inicializar a variável "let" com um valor padrão. Se o tipo declarado for String, Int ou Bool, o valor padrão correspondente é carregado diretamente. Caso contrário, o código para a expressão de inicialização é gerado. Em seguida, o corpo da expressão "let" é executado.

O método code da classe `code_dispatch` é responsável por gerar o código para o dispatch do método. Ela recebe como argumentos a expressão que representa o objeto receptor do dispatch, o nome do método, a lista de argumentos atuais, o tipo alvo do dispatch, a definição da classe atual e o número da linha atual. Primeiro, ela itera sobre os argumentos atuais, gerando o código para avaliá-los e empilhá-los. Em seguida, gera o código para avaliar a expressão do objeto receptor do dispatch. Depois disso, verifica se o objeto receptor é válido (diferente de zero) e, caso contrário, trata o dispatch para um objeto nulo. Se o objeto for válido, carrega o endereço da tabela de dispatch do tipo alvo e, em seguida, carrega o endereço do método a ser chamado. Por fim, realiza um salto indireto para o método.

O método code da classe `static_dispatch_class` é uma subclasse que representa o dispatch de métodos estáticos. Ela sobrescreve o método code para chamar a classe code_dispatch do contexto atual, passando os argumentos relevantes.

O método code da classe `dispatch_class` é uma subclasse que representa o dispatch de métodos dinâmicos. Ela também sobrescreve o método code para chamar a classe code_dispatch do contexto atual, passando os argumentos relevantes.

O método code da classe `typcase_class` é responsável por gerar o código para a expressão case em Cool. Ela analisa cada ramo (caso) da expressão, ordena-os de acordo com as tags de classificação e gera código para verificar o tipo dinâmico do objeto e executar o código correspondente ao ramo adequado. Caso nenhum ramo corresponda, é gerado código para lidar com a falha do case.

O método code da classe `new__class` gera o código para a expressão new em Cool. Ela cria uma nova instância de um objeto, inicializando-a e invocando o método de inicialização da classe correspondente. O código também trata do objeto SELF_TYPE e empilha o objeto recém-criado na pilha. Por fim, o método da classe é carregado e é feito um salto para sua execução.

Os métodos code das classes `string_const_class`, `bool_const_class`, `object_class` e `int_const_class` representam geração de código para tipos básicos em cool.

Os métodos code das classes `plus_class`, `sub_class`, `mul_class`, `divide_class` são  métodos para geração de código das operações aritméticas em cool.

Os métodos code das classes`neg_class`, `lt_class`, `eq_class`, `leq_class` e `comp_class` são métodos para geração das operações de tipo lógicas em cool.

O método code da classe `void no_expr_class` representa uma expressão vazia em Cool, o que é equivalente a uma instrução NOP (No Operation) em outras linguagens. Nesse caso, ele simplesmente move o valor zero para o registrador ACC.

O método code da classe `isvoid_class` verifica se uma expressão é nula (void) em Cool. Se a expressão for nula, ele carrega true no registrador ACC; caso contrário, carrega false.